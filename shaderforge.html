<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ShaderForge - Interactive WebGL shader playground with genetic algorithm evolution">
    <meta name="keywords" content="WebGL, GLSL, shaders, genetic algorithm, visual effects, creative coding">
    <meta name="author" content="ShaderForge">
    <title>ShaderForge - Interactive Shader Playground</title>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎨</text></svg>">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        /* Canvas - Full Screen */
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 1;
        }

        /* Editor Panel */
        #editor-panel {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 550px;
            max-height: calc(100vh - 40px);
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #4ecdc4;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3);
        }

        /* Header */
        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            font-size: 2em;
        }

        h1 {
            font-size: 1.5em;
            background: linear-gradient(45deg, #4ecdc4, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tagline {
            font-size: 0.8em;
            opacity: 0.7;
            font-style: italic;
        }

        /* Buttons */
        button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
        }

        .btn-success {
            background: linear-gradient(45deg, #51cf66, #37b24d);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffd43b, #fab005);
            color: #000;
        }

        .btn-purple {
            background: linear-gradient(45deg, #9775fa, #7950f2);
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .btn-group button {
            flex: 1;
            min-width: 100px;
        }

        /* Code Editor */
        #shader-editor {
            width: 100%;
            height: 350px;
            background: #0a0a0a;
            color: #4ecdc4;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            tab-size: 4;
            overflow: auto;
        }

        #shader-editor:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }

        /* Error Display */
        #error-display {
            margin-top: 10px;
            padding: 12px;
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid #ff6b6b;
            border-radius: 6px;
            color: #ff6b6b;
            font-size: 0.85em;
            display: none;
            max-height: 100px;
            overflow-y: auto;
        }

        #error-display.show {
            display: block;
        }

        /* Section Headers */
        .section {
            margin: 20px 0;
            padding: 15px 0;
            border-top: 1px solid #333;
        }

        .section h3 {
            font-size: 1.1em;
            margin-bottom: 12px;
            color: #4ecdc4;
        }

        /* Preset Buttons */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .preset-btn {
            padding: 8px 10px;
            font-size: 0.75em;
            min-width: auto;
        }

        /* Stats Display */
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.85em;
        }

        .stat-item {
            background: rgba(78, 205, 196, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .stat-label {
            opacity: 0.7;
            font-size: 0.9em;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2em;
            color: #4ecdc4;
        }

        /* Evolution Controls */
        .evolution-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .like-skip {
            display: flex;
            gap: 8px;
        }

        .like-skip button {
            font-size: 1.2em;
            padding: 12px 20px;
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.9em;
            z-index: 999;
            border: 1px solid #333;
        }

        #fps-value {
            color: #4ecdc4;
            font-weight: bold;
        }

        /* Saved Shaders Library */
        .library {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            padding: 10px;
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .library-item:hover {
            background: rgba(78, 205, 196, 0.2);
            transform: translateX(5px);
        }

        .library-item-name {
            flex: 1;
            font-size: 0.9em;
        }

        .library-item-delete {
            background: transparent;
            padding: 4px 8px;
            font-size: 0.8em;
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }

        /* Save Modal */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.98);
            border: 2px solid #4ecdc4;
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            min-width: 300px;
        }

        .modal.show {
            display: block;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1999;
        }

        .modal-overlay.show {
            display: block;
        }

        .modal h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
        }

        .modal input {
            width: 100%;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            margin-bottom: 15px;
        }

        .modal input:focus {
            outline: none;
            border-color: #4ecdc4;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-buttons button {
            flex: 1;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(78, 205, 196, 0.95);
            color: #000;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: bold;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .notification.show {
            opacity: 1;
        }

        .notification.error {
            background: rgba(255, 107, 107, 0.95);
            color: white;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4ecdc4;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #editor-panel {
                width: calc(100% - 20px);
                right: 10px;
                top: 10px;
                max-height: calc(100vh - 20px);
            }

            #shader-editor {
                height: 250px;
            }

            .preset-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            #fps-counter {
                top: 10px;
                left: 10px;
                font-size: 0.8em;
            }
        }

        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- Main Canvas -->
    <canvas id="canvas"></canvas>

    <!-- FPS Counter -->
    <div id="fps-counter">
        FPS: <span id="fps-value">60</span>
    </div>

    <!-- Editor Panel -->
    <div id="editor-panel">
        <!-- Header -->
        <div class="editor-header">
            <div class="logo">
                <span class="logo-icon">🎨</span>
                <div>
                    <h1>ShaderForge</h1>
                    <div class="tagline">Interactive Shader Evolution</div>
                </div>
            </div>
        </div>

        <!-- Compile Button -->
        <button id="compile-btn" class="btn-success">▶ Compile Shader (Ctrl+Enter)</button>

        <!-- Shader Editor -->
        <textarea id="shader-editor" spellcheck="false" placeholder="Write your GLSL fragment shader here..."></textarea>

        <!-- Error Display -->
        <div id="error-display"></div>

        <!-- Presets Section -->
        <div class="section">
            <h3>📚 Shader Presets</h3>
            <div class="preset-grid" id="preset-buttons">
                <!-- Presets will be added dynamically -->
            </div>
        </div>

        <!-- Evolution Section -->
        <div class="section">
            <h3>🧬 Genetic Evolution</h3>
            <div class="btn-group">
                <button id="evolve-start-btn" class="btn-purple">Start Evolution</button>
                <button id="evolve-stop-btn" class="btn-danger" disabled>Stop Evolution</button>
            </div>
            <div class="evolution-controls">
                <div class="like-skip">
                    <button id="like-btn" class="btn-success" disabled>❤️ Like</button>
                    <button id="skip-btn" class="btn-warning" disabled>➡️ Skip</button>
                </div>
                <button id="random-btn">🎲 Random</button>
            </div>
        </div>

        <!-- Stats Section -->
        <div class="section">
            <h3>📊 Statistics</h3>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Generation</div>
                    <div class="stat-value" id="generation-stat">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Shader #</div>
                    <div class="stat-value" id="shader-stat">0/0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Fitness</div>
                    <div class="stat-value" id="fitness-stat">0.0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Library</div>
                    <div class="stat-value" id="library-stat">0</div>
                </div>
            </div>
        </div>

        <!-- Save/Export Section -->
        <div class="section">
            <h3>💾 Save & Export</h3>
            <div class="btn-group">
                <button id="save-btn" class="btn-success">Save Current</button>
                <button id="export-btn">📋 Copy Code</button>
                <button id="screenshot-btn">📸 Screenshot</button>
            </div>
        </div>

        <!-- Library Section -->
        <div class="section">
            <h3>📂 Saved Shaders</h3>
            <div class="library" id="library">
                <div style="text-align: center; opacity: 0.5; padding: 20px;">
                    No saved shaders yet
                </div>
            </div>
        </div>

        <!-- Info -->
        <div class="section" style="border-top: none; padding-top: 0;">
            <div style="font-size: 0.75em; opacity: 0.5; text-align: center;">
                Part of the Evolution Trilogy: 
                <a href="https://jamesthegiblet.github.io/Primordial/" style="color: #4ecdc4;">Primordial</a> • 
                MelodyForge • 
                ShaderForge
            </div>
        </div>
    </div>

    <!-- Save Modal -->
    <div class="modal-overlay" id="modal-overlay"></div>
    <div class="modal" id="save-modal">
        <h3>Save Shader</h3>
        <input type="text" id="shader-name-input" placeholder="Enter shader name..." maxlength="50">
        <div class="modal-buttons">
            <button id="save-confirm-btn" class="btn-success">Save</button>
            <button id="save-cancel-btn" class="btn-danger">Cancel</button>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // =====================================================================
        // SHADERFORGE - INTERACTIVE SHADER PLAYGROUND WITH EVOLUTION
        // =====================================================================
        
        class ShaderForge {
            constructor() {
                console.log('🎨 Initializing ShaderForge...');
                
                // Canvas & WebGL
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl2') || 
                          this.canvas.getContext('webgl') ||
                          this.canvas.getContext('experimental-webgl');
                
                if (!this.gl) {
                    alert('WebGL not supported! Please use a modern browser.');
                    return;
                }
                
                console.log('✅ WebGL initialized');
                
                // DOM Elements
                this.editor = document.getElementById('shader-editor');
                this.compileBtn = document.getElementById('compile-btn');
                this.errorDisplay = document.getElementById('error-display');
                this.fpsValue = document.getElementById('fps-value');
                
                // Evolution Elements
                this.evolveStartBtn = document.getElementById('evolve-start-btn');
                this.evolveStopBtn = document.getElementById('evolve-stop-btn');
                this.likeBtn = document.getElementById('like-btn');
                this.skipBtn = document.getElementById('skip-btn');
                this.randomBtn = document.getElementById('random-btn');
                
                // Stats Elements
                this.generationStat = document.getElementById('generation-stat');
                this.shaderStat = document.getElementById('shader-stat');
                this.fitnessStat = document.getElementById('fitness-stat');
                this.libraryStat = document.getElementById('library-stat');
                
                // Save/Export Elements
                this.saveBtn = document.getElementById('save-btn');
                this.exportBtn = document.getElementById('export-btn');
                this.screenshotBtn = document.getElementById('screenshot-btn');
                this.library = document.getElementById('library');
                
                // Modal Elements
                this.saveModal = document.getElementById('save-modal');
                this.modalOverlay = document.getElementById('modal-overlay');
                this.shaderNameInput = document.getElementById('shader-name-input');
                this.saveConfirmBtn = document.getElementById('save-confirm-btn');
                this.saveCancelBtn = document.getElementById('save-cancel-btn');
                
                // Notification
                this.notification = document.getElementById('notification');
                
                // State
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.mouseX = 0;
                this.mouseY = 0;
                this.isEvolving = false;
                this.currentGenome = null;
                this.currentGenomeIndex = 0;
                this.generation = 0;
                this.population = [];
                this.populationSize = 20;
                this.savedShaders = this.loadFromStorage();
                
                // Initialize
                this.resizeCanvas();
                this.initPresets();
                this.initEventListeners();
                this.loadDefaultShader();
                this.updateLibraryDisplay();
                this.render();
                
                console.log('✅ ShaderForge ready!');
                this.showNotification('ShaderForge initialized! Press Ctrl+Enter to compile.');
            }
            
            // =====================================================================
            // WEBGL SETUP
            // =====================================================================
            
            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                
                if (this.gl) {
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }
            
            createShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const error = this.gl.getShaderInfoLog(shader);
                    console.error('Shader compilation error:', error);
                    this.showError(error);
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(vertexSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.createShader(fragmentSource, this.gl.FRAGMENT_SHADER);
                
                if (!vertexShader || !fragmentShader) {
                    return null;
                }
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    const error = this.gl.getProgramInfoLog(program);
                    console.error('Program linking error:', error);
                    this.showError(error);
                    return null;
                }
                
                // Clean up shaders
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);
                
                return program;
            }
            
            setupGeometry(program) {
                // Fullscreen quad
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                const buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                const positionLoc = this.gl.getAttribLocation(program, 'position');
                this.gl.enableVertexAttribArray(positionLoc);
                this.gl.vertexAttribPointer(positionLoc, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            compileShader() {
                const fragmentSource = this.editor.value;
                
                try {
                    const newProgram = this.createProgram(
                        this.getVertexShader(),
                        fragmentSource
                    );
                    
                    if (newProgram) {
                        if (this.program) {
                            this.gl.deleteProgram(this.program);
                        }
                        this.program = newProgram;
                        this.setupGeometry(this.program);
                        this.showError(null);
                        this.showNotification('✅ Shader compiled successfully!');
                        return true;
                    }
                } catch (error) {
                    this.showError(error.message);
                    this.showNotification('❌ Compilation failed!', true);
                    return false;
                }
                
                return false;
            }
            
            // =====================================================================
            // RENDERING
            // =====================================================================
            
            render() {
                requestAnimationFrame(() => this.render());
                
                if (!this.program) return;
                
                const time = (Date.now() - this.startTime) / 1000.0;
                
                this.gl.useProgram(this.program);
                
                // Set uniforms
                const timeLoc = this.gl.getUniformLocation(this.program, 'u_time');
                const resolutionLoc = this.gl.getUniformLocation(this.program, 'u_resolution');
                const mouseLoc = this.gl.getUniformLocation(this.program, 'u_mouse');
                
                if (timeLoc) this.gl.uniform1f(timeLoc, time);
                if (resolutionLoc) this.gl.uniform2f(resolutionLoc, this.canvas.width, this.canvas.height);
                if (mouseLoc) this.gl.uniform2f(mouseLoc, this.mouseX, this.mouseY);
                
                // Draw
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                
                // Update FPS
                this.updateFPS();
            }
            
            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                const elapsed = now - this.lastFpsUpdate;
                
                if (elapsed >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / elapsed);
                    this.fpsValue.textContent = fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
            }
            
            // =====================================================================
            // DEFAULT SHADERS
            // =====================================================================
            
            getVertexShader() {
                return `
                    attribute vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;
            }
            
            getDefaultFragmentShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;
uniform vec2 u_mouse;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    
    // Animated gradient
    vec3 color = 0.5 + 0.5 * cos(u_time + st.xyx + vec3(0.0, 2.0, 4.0));
    
    // Mouse interaction
    vec2 mouse = u_mouse / u_resolution;
    float dist = distance(st, mouse);
    color *= 1.0 - smoothstep(0.0, 0.3, dist);
    
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            loadDefaultShader() {
                this.editor.value = this.getDefaultFragmentShader();
                this.compileShader();
            }
            
            // =====================================================================
            // PRESET SHADERS
            // =====================================================================
            
            initPresets() {
                this.presets = {
                    'Default': this.getDefaultFragmentShader(),
                    'Rainbow': this.getRainbowShader(),
                    'Plasma': this.getPlasmaShader(),
                    'Mandelbrot': this.getMandelbrotShader(),
                    'Tunnel': this.getTunnelShader(),
                    'Voronoi': this.getVoronoiShader(),
                    'Waves': this.getWavesShader(),
                    'Noise': this.getNoiseShader(),
                    'Spiral': this.getSpiralShader()
                };
                
                const container = document.getElementById('preset-buttons');
                
                Object.keys(this.presets).forEach(name => {
                    const btn = document.createElement('button');
                    btn.className = 'preset-btn';
                    btn.textContent = name;
                    btn.addEventListener('click', () => this.loadPreset(name));
                    container.appendChild(btn);
                });
            }
            
            loadPreset(name) {
                this.editor.value = this.presets[name];
                this.compileShader();
                this.showNotification(`Loaded preset: ${name}`);
            }
            
            getRainbowShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    vec3 color = 0.5 + 0.5 * cos(u_time + st.xyx + vec3(0, 2, 4));
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            getPlasmaShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    float v = 0.0;
    v += sin((st.x + u_time));
    v += sin((st.y + u_time) / 2.0);
    v += sin((st.x + st.y + u_time) / 2.0);
    vec2 c = st + 0.5 * vec2(sin(u_time / 3.0), cos(u_time / 2.0));
    v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0) + u_time);
    v = v / 2.0;
    vec3 col = vec3(1, sin(3.14159 * v), cos(3.14159 * v));
    gl_FragColor = vec4(col * 0.5 + 0.5, 1.0);
}`;
            }
            
            getMandelbrotShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 c = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
    c = c * 2.0 - vec2(0.5, 0.0);
    c *= 1.0 + 0.5 * sin(u_time * 0.1);
    
    vec2 z = vec2(0.0);
    float iterations = 0.0;
    
    for(int i = 0; i < 100; i++) {
        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
        if(length(z) > 2.0) break;
        iterations += 1.0;
    }
    
    float color = iterations / 100.0;
    vec3 col = vec3(color, color * 0.5, color * 0.25);
    gl_FragColor = vec4(col, 1.0);
}`;
            }
            
            getTunnelShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    vec2 p = st * 2.0 - 1.0;
    p.x *= u_resolution.x / u_resolution.y;
    
    float r = length(p);
    float a = atan(p.y, p.x);
    
    float u = 1.0 / r + u_time;
    float v = a / 3.14159;
    
    vec3 color = 0.5 + 0.5 * cos(u_time + vec3(u, v, u + v) * 3.0);
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            getVoronoiShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

vec2 random2(vec2 p) {
    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
}

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    st *= 5.0;
    
    vec2 i_st = floor(st);
    vec2 f_st = fract(st);
    
    float min_dist = 1.0;
    
    for(int j = -1; j <= 1; j++) {
        for(int i = -1; i <= 1; i++) {
            vec2 neighbor = vec2(float(i), float(j));
            vec2 point = random2(i_st + neighbor);
            point = 0.5 + 0.5 * sin(u_time + 6.2831 * point);
            vec2 diff = neighbor + point - f_st;
            float dist = length(diff);
            min_dist = min(min_dist, dist);
        }
    }
    
    vec3 color = vec3(min_dist);
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            getWavesShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    float y = st.y;
    
    y += 0.1 * sin(st.x * 10.0 + u_time);
    y += 0.05 * sin(st.x * 20.0 - u_time * 2.0);
    y += 0.025 * sin(st.x * 40.0 + u_time * 3.0);
    
    float wave = smoothstep(0.48, 0.52, y);
    vec3 color = mix(vec3(0.1, 0.2, 0.4), vec3(0.4, 0.8, 1.0), wave);
    
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            getNoiseShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    st *= 10.0;
    
    vec2 ipos = floor(st);
    vec2 fpos = fract(st);
    
    float n = random(ipos + u_time * 0.1);
    
    vec3 color = vec3(n);
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            getSpiralShader() {
                return `precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    vec2 pos = st - 0.5;
    
    float r = length(pos) * 2.0;
    float a = atan(pos.y, pos.x);
    
    float f = cos(a * 10.0 + r * 20.0 - u_time * 2.0);
    
    vec3 color = vec3(f * 0.5 + 0.5);
    gl_FragColor = vec4(color, 1.0);
}`;
            }
            
            // =====================================================================
            // EVENT LISTENERS
            // =====================================================================
            
            initEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Mouse move
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = this.canvas.height - (e.clientY - rect.top);
                });
                
                // Compile button
                this.compileBtn.addEventListener('click', () => this.compileShader());
                
                // Keyboard shortcuts
                this.editor.addEventListener('keydown', (e) => {
                    // Ctrl+Enter to compile
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        e.preventDefault();
                        this.compileShader();
                    }
                    
                    // Tab handling
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = this.editor.selectionStart;
                        const end = this.editor.selectionEnd;
                        this.editor.value = this.editor.value.substring(0, start) + 
                                           '    ' + 
                                           this.editor.value.substring(end);
                        this.editor.selectionStart = this.editor.selectionEnd = start + 4;
                    }
                });
                
                // Evolution buttons
                this.evolveStartBtn.addEventListener('click', () => this.startEvolution());
                this.evolveStopBtn.addEventListener('click', () => this.stopEvolution());
                this.likeBtn.addEventListener('click', () => this.likeGenome());
                this.skipBtn.addEventListener('click', () => this.skipGenome());
                this.randomBtn.addEventListener('click', () => this.loadRandomGenome());
                
                // Save/Export buttons
                this.saveBtn.addEventListener('click', () => this.showSaveModal());
                this.exportBtn.addEventListener('click', () => this.exportCode());
                this.screenshotBtn.addEventListener('click', () => this.takeScreenshot());
                
                // Modal buttons
                this.saveConfirmBtn.addEventListener('click', () => this.confirmSave());
                this.saveCancelBtn.addEventListener('click', () => this.hideSaveModal());
                this.modalOverlay.addEventListener('click', () => this.hideSaveModal());
                
                // Enter key in save modal
                this.shaderNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.confirmSave();
                    }
                });
            }
            
            // =====================================================================
            // GENETIC ALGORITHM (PLACEHOLDER - TO BE IMPLEMENTED)
            // =====================================================================
            
            startEvolution() {
                this.isEvolving = true;
                this.evolveStartBtn.disabled = true;
                this.evolveStopBtn.disabled = false;
                this.likeBtn.disabled = false;
                this.skipBtn.disabled = false;
                
                // Initialize population
                this.initializePopulation();
                this.loadGenome(this.population[0]);
                
                this.showNotification('🧬 Evolution started! Rate shaders with Like/Skip.');
            }
            
            stopEvolution() {
                this.isEvolving = false;
                this.evolveStartBtn.disabled = false;
                this.evolveStopBtn.disabled = true;
                this.likeBtn.disabled = true;
                this.skipBtn.disabled = true;
                
                this.showNotification('Evolution stopped.');
            }
            
            initializePopulation() {
                this.population = [];
                this.generation = 0;
                this.currentGenomeIndex = 0;
                
                // Create random genomes
                for (let i = 0; i < this.populationSize; i++) {
                    this.population.push(this.createRandomGenome());
                }
                
                this.updateStats();
            }
            
            createRandomGenome() {
                return {
                    id: Math.random().toString(36).substr(2, 9),
                    code: this.presets[Object.keys(this.presets)[Math.floor(Math.random() * Object.keys(this.presets).length)]],
                    fitness: 0
                };
            }
            
            loadGenome(genome) {
                this.currentGenome = genome;
                this.editor.value = genome.code;
                this.compileShader();
                this.updateStats();
            }
            
            likeGenome() {
                if (this.currentGenome) {
                    this.currentGenome.fitness += 1;
                    this.nextGenome();
                }
            }
            
            skipGenome() {
                if (this.currentGenome) {
                    this.currentGenome.fitness -= 0.5;
                    this.nextGenome();
                }
            }
            
            nextGenome() {
                this.currentGenomeIndex++;
                
                if (this.currentGenomeIndex >= this.population.length) {
                    this.evolvePopulation();
                    this.currentGenomeIndex = 0;
                    this.generation++;
                }
                
                this.loadGenome(this.population[this.currentGenomeIndex]);
            }
            
            evolvePopulation() {
                // Sort by fitness
                this.population.sort((a, b) => b.fitness - a.fitness);
                
                // Keep top 30%
                const eliteCount = Math.floor(this.populationSize * 0.3);
                const newPopulation = this.population.slice(0, eliteCount);
                
                // Fill rest with variations
                while (newPopulation.length < this.populationSize) {
                    const parent = this.population[Math.floor(Math.random() * eliteCount)];
                    newPopulation.push({
                        ...parent,
                        id: Math.random().toString(36).substr(2, 9),
                        fitness: 0
                    });
                }
                
                this.population = newPopulation;
                this.showNotification(`🧬 Generation ${this.generation + 1} created!`);
            }
            
            loadRandomGenome() {
                const genome = this.createRandomGenome();
                this.loadGenome(genome);
                this.showNotification('🎲 Loaded random shader');
            }
            
            // =====================================================================
            // SAVE/LOAD SYSTEM
            // =====================================================================
            
            showSaveModal() {
                this.saveModal.classList.add('show');
                this.modalOverlay.classList.add('show');
                this.shaderNameInput.value = '';
                this.shaderNameInput.focus();
            }
            
            hideSaveModal() {
                this.saveModal.classList.remove('show');
                this.modalOverlay.classList.remove('show');
            }
            
            confirmSave() {
                const name = this.shaderNameInput.value.trim();
                
                if (!name) {
                    this.showNotification('Please enter a name!', true);
                    return;
                }
                
                const shader = {
                    id: Date.now().toString(),
                    name: name,
                    code: this.editor.value,
                    timestamp: new Date().toISOString()
                };
                
                this.savedShaders.push(shader);
                this.saveToStorage();
                this.updateLibraryDisplay();
                this.hideSaveModal();
                
                this.showNotification(`✅ Saved: ${name}`);
            }
            
            loadFromStorage() {
                try {
                    const data = localStorage.getItem('shaderforge-library');
                    return data ? JSON.parse(data) : [];
                } catch (e) {
                    console.error('Error loading from storage:', e);
                    return [];
                }
            }
            
            saveToStorage() {
                try {
                    localStorage.setItem('shaderforge-library', JSON.stringify(this.savedShaders));
                } catch (e) {
                    console.error('Error saving to storage:', e);
                    this.showNotification('Error saving to storage!', true);
                }
            }
            
            updateLibraryDisplay() {
                if (this.savedShaders.length === 0) {
                    this.library.innerHTML = '<div style="text-align: center; opacity: 0.5; padding: 20px;">No saved shaders yet</div>';
                    this.libraryStat.textContent = '0';
                    return;
                }
                
                this.library.innerHTML = '';
                
                this.savedShaders.forEach(shader => {
                    const item = document.createElement('div');
                    item.className = 'library-item';
                    
                    const name = document.createElement('div');
                    name.className = 'library-item-name';
                    name.textContent = shader.name;
                    name.addEventListener('click', () => {
                        this.editor.value = shader.code;
                        this.compileShader();
                        this.showNotification(`Loaded: ${shader.name}`);
                    });
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'library-item-delete';
                    deleteBtn.textContent = '✕';
                    deleteBtn.addEventListener('click', () => {
                        this.savedShaders = this.savedShaders.filter(s => s.id !== shader.id);
                        this.saveToStorage();
                        this.updateLibraryDisplay();
                        this.showNotification(`Deleted: ${shader.name}`);
                    });
                    
                    item.appendChild(name);
                    item.appendChild(deleteBtn);
                    this.library.appendChild(item);
                });
                
                this.libraryStat.textContent = this.savedShaders.length;
            }
            
            // =====================================================================
            // EXPORT FUNCTIONS
            // =====================================================================
            
            exportCode() {
                const code = this.editor.value;
                
                navigator.clipboard.writeText(code).then(() => {
                    this.showNotification('📋 Code copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.showNotification('Failed to copy code!', true);
                });
            }
            
            takeScreenshot() {
                try {
                    this.canvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = `shaderforge-${Date.now()}.png`;
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                        
                        this.showNotification('📸 Screenshot saved!');
                    });
                } catch (err) {
                    console.error('Screenshot failed:', err);
                    this.showNotification('Screenshot failed!', true);
                }
            }
            
            // =====================================================================
            // UI HELPERS
            // =====================================================================
            
            showError(message) {
                if (message) {
                    this.errorDisplay.textContent = message;
                    this.errorDisplay.classList.add('show');
                } else {
                    this.errorDisplay.classList.remove('show');
                }
            }
            
            showNotification(message, isError = false) {
                this.notification.textContent = message;
                this.notification.classList.add('show');
                
                if (isError) {
                    this.notification.classList.add('error');
                } else {
                    this.notification.classList.remove('error');
                }
                
                setTimeout(() => {
                    this.notification.classList.remove('show');
                }, 3000);
            }
            
            updateStats() {
                this.generationStat.textContent = this.generation;
                this.shaderStat.textContent = `${this.currentGenomeIndex + 1}/${this.populationSize}`;
                this.fitnessStat.textContent = this.currentGenome ? this.currentGenome.fitness.toFixed(1) : '0.0';
            }
        }
        
        // Initialize when DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            window.shaderForge = new ShaderForge();
        });
    </script>
</body>
</html>
